use lalrpop_util::ErrorRecovery;
use crate::{
    CapacityBlock, MultiplierBlock, InhibitorBlock,
    Rex, ThinArrowRule, FatArrowRule, Polynomial, BinOp, Literal,
};

grammar<'env>(errors: &'env mut Vec<ErrorRecovery<usize, Token<'input>, &'static str>>);

// Context

// context_block = vis_block | cap_block | mul_block | inh_block ;

// cap_block = "cap" "{" cap_list "}" ;
pub CapBlock: CapacityBlock =
    "cap" "{" <head: CapSpec> <tail: CommaThenCapSpec*> ","? "}" =>
        head.with_more(tail);

// cap_list = cap_spec { "," cap_spec } [ "," ] ;
CommaThenCapSpec: CapacityBlock = "," <CapSpec>;

// cap_spec ::= size node_list ;
CapSpec: CapacityBlock =
    <size: Size> <nodes: NodeList> =>
        CapacityBlock::new(size, nodes).unwrap();

// mul_block = "mul" "{" mul_list "}" ;
pub MulBlock: MultiplierBlock =
    "mul" "{" <head: MulSpec> <tail: CommaThenMulSpec*> ","? "}" =>
        head.with_more(tail);

// mul_list = mul_spec { "," mul_spec } [ "," ] ;
CommaThenMulSpec: MultiplierBlock = "," <MulSpec>;

// mul_spec = size node_list ( "->" | "<-" ) node_list ;
MulSpec: MultiplierBlock = {
    <size: Size> <pre_nodes: NodeList> "->" <post_set: NodeList> =>
        MultiplierBlock::new_effects(size, pre_nodes, post_set).unwrap(),
    <size: Size> <post_nodes: NodeList> "<-" <pre_set: NodeList> =>
        MultiplierBlock::new_causes(size, post_nodes, pre_set).unwrap(),
};

// inh_block = "inh" "{" inh_list "}" ;
pub InhBlock: InhibitorBlock =
    "inh" "{" <head: InhSpec> <tail: CommaThenInhSpec*> ","? "}" =>
        head.with_more(tail);

// inh_list = inh_spec { "," inh_spec } [ "," ] ;
CommaThenInhSpec: InhibitorBlock = "," <InhSpec>;

// inh_spec = node_list ( "->" | "<-" ) node_list ;
InhSpec: InhibitorBlock = {
    <pre_nodes: NodeList> "->" <post_set: NodeList> =>
        InhibitorBlock::new_effects(pre_nodes, post_set).unwrap(),
    <post_nodes: NodeList> "<-" <pre_set: NodeList> =>
        InhibitorBlock::new_causes(post_nodes, pre_set).unwrap(),
};

// Rule expression

// rex = "{" thin_arrow_rule "}"
//     | "{" fat_arrow_rule "}"
//     | "{" rex { [ "+" ] rex } "}" ;
pub Rex: Rex = {
    "{" <ThinArrowRule> "}" => Rex::from_thin_rule(<>),
    "{" <FatArrowRule> "}" => Rex::from_fat_rule(<>),
    "{" <head: Rex> <tail: (<AddOp?> <Rex>)*> "}" => head.with_more(tail),
};

// Arrow rules

// thin_arrow_rule = e_rule | c_rule | ec_rule | ce_rule | fw_rule | bw_rule ;
// e_rule = node_list "->" polynomial ;
// c_rule = node_list "<-" polynomial ;
// ec_rule = node_list "->" polynomial "<-" polynomial ;
// ce_rule = node_list "<-" polynomial "->" polynomial ;
// fw_rule = "+" plain_polynomial "->" node_list "->" polynomial ;
// bw_rule = "+" plain_polynomial "<-" node_list "<-" polynomial ;
pub ThinArrowRule: ThinArrowRule = {
    // effect-only rule
    <nodes: Polynomial> "->" <effect: Polynomial> => {
        ThinArrowRule::new().with_nodes(nodes).unwrap().with_effect(effect)
    },
    // cause-only rule
    <nodes: Polynomial> "<-" <cause: Polynomial> => {
        ThinArrowRule::new().with_nodes(nodes).unwrap().with_cause(cause)
    },
    // effect-then-cause rule
    <nodes: Polynomial> "->" <effect: Polynomial> "<-" <cause: Polynomial> => {
        ThinArrowRule::new().with_nodes(nodes).unwrap().with_cause(cause).with_effect(effect)
    },
    // cause-then-effect rule
    <nodes: Polynomial> "<-" <cause: Polynomial> "->" <effect: Polynomial> => {
        ThinArrowRule::new().with_nodes(nodes).unwrap().with_cause(cause).with_effect(effect)
    },
    // forward rule
    <cause: Polynomial> "->" <nodes: Polynomial> "->" <effect: Polynomial> => {
        ThinArrowRule::new().with_nodes(nodes).unwrap().with_cause(cause).with_effect(effect)
    },
    // backward rule
    <effect: Polynomial> "<-" <nodes: Polynomial> "<-" <cause: Polynomial> => {
        ThinArrowRule::new().with_nodes(nodes).unwrap().with_cause(cause).with_effect(effect)
    },
};

// fat_arrow_rule = polynomial ( "=>" | "<=" ) polynomial { ( "=>" | "<=" ) polynomial } ;
pub FatArrowRule: FatArrowRule =
    <head: Polynomial> <tail: (<FatOp> <Polynomial>)+> =>
        FatArrowRule::from_parts(head, tail);

// Polynomial

// polynomial = [ [ polynomial ] "+" ] poly_term { poly_term } ;
pub Polynomial: Polynomial = {
    AddOp? <head: PolyTerm> <tail: PolyTerm*> => head.with_product_multiplied(tail),
    <head: Polynomial> AddOp <tail: PolyTerm+> => head.with_product_added(tail),
};

// poly_term = identifier | "(" polynomial ")" ;
PolyTerm: Polynomial = {
    <Identifier> => Polynomial::from(<>),
    "(" <Polynomial> ")",
};

NodeList: Polynomial = <Polynomial>;

// Operators

AddOp: BinOp = "+" => BinOp::Add;
ThinOp: BinOp = { "->" => BinOp::ThinTx, "<-" => BinOp::ThinRx };
FatOp: BinOp = { "=>" => BinOp::FatTx, "<=" => BinOp::FatRx };

// Identifiers

Identifier: String = r"[A-Za-z_][A-Za-z0-9_]*" => <>.to_owned();

// Literals

Size: Literal = r"[0-9]+" => Literal::from_digits(<>).unwrap();
Name: Literal = r#""[^"]*""# => Literal::from_quoted_str(<>).unwrap();
