use lalrpop_util::ErrorRecovery;
use crate::{Rex, Rule, ThinRule, FatRule, NodeList, Polynomial, BinOp, Literal};

grammar<'env>(errors: &'env mut Vec<ErrorRecovery<usize, Token<'input>, &'static str>>);

// Rule expression

// rex = "{" rule "}"
//     | "{" rex { [ "+" ] rex } "}" ;
pub Rex: Rex = {
    "{" <Rule> "}" => Rex::from_rule(<>),
    "{" <head: Rex> <tail: (<AddOp?> <Rex>)*> "}" => head.with_more(tail),
};

// Rules

// rule = thin_rule | fat_rule ;
Rule: Rule = {
    <ThinRule> => Rule::Thin(<>),
    <FatRule> => Rule::Fat(<>),
};

// thin_rule = e_rule | c_rule | ec_rule | ce_rule | fw_rule | bw_rule ;
// e_rule = node_list "->" polynomial ;
// c_rule = node_list "<-" polynomial ;
// ec_rule = node_list "->" polynomial "<-" polynomial ;
// ce_rule = node_list "<-" polynomial "->" polynomial ;
// fw_rule = "+" plain_polynomial "->" node_list "->" polynomial ;
// bw_rule = "+" plain_polynomial "<-" node_list "<-" polynomial ;
ThinRule: ThinRule = {
    // effect-only rule
    <nodes: NodeList> "->" <effect: Polynomial> => {
        ThinRule::new().with_nodes(nodes).with_effect(effect)
    },
    // cause-only rule
    <nodes: NodeList> "<-" <cause: Polynomial> => {
        ThinRule::new().with_nodes(nodes).with_cause(cause)
    },
    // effect-then-cause rule
    <nodes: NodeList> "->" <effect: Polynomial> "<-" <cause: Polynomial> => {
        ThinRule::new().with_nodes(nodes).with_cause(cause).with_effect(effect)
    },
    // cause-then-effect rule
    <nodes: NodeList> "<-" <cause: Polynomial> "->" <effect: Polynomial> => {
        ThinRule::new().with_nodes(nodes).with_cause(cause).with_effect(effect)
    },
    // forward rule
    "+" <cause: PlainPolynomial> "->" <nodes: NodeList> "->" <effect: Polynomial> => {
        ThinRule::new().with_nodes(nodes).with_cause(cause).with_effect(effect)
    },
    // backward rule
    "+" <effect: PlainPolynomial> "<-" <nodes: NodeList> "<-" <cause: Polynomial> => {
        ThinRule::new().with_nodes(nodes).with_cause(cause).with_effect(effect)
    },
};

// node_list = node_ident { "," node_ident } [ "," ] ;
NodeList: NodeList = {
    <head: NodeIdent> <tail: CommaNodeIdent*> ","? => NodeList::from_node(head).with_more(tail),
};

CommaNodeIdent: String = "," <NodeIdent>;

// fat_rule = polynomial ( "=>" | "<=" ) polynomial { ( "=>" | "<=" ) polynomial } ;
FatRule: FatRule =
    <head: Polynomial> <tail: (<FatOp> <Polynomial>)+> =>
        FatRule::from_parts(head, tail);

// Polynomial

// polynomial = [ "+" ] plain_polynomial ;
Polynomial: Polynomial = "+"? <PlainPolynomial>;

// plain_polynomial = [ plain_polynomial "+" ] poly_term { poly_term } ;
PlainPolynomial: Polynomial = {
    <head: PolyTerm> <tail: PolyTerm*> => head.with_product_multiplied(tail),
    <head: PlainPolynomial> AddOp <tail: PolyTerm+> => head.with_product_added(tail),
};

// poly_term = node_ident | "(" polynomial ")" ;
PolyTerm: Polynomial = {
    <NodeIdent> => Polynomial::from_node(<>),
    "(" <Polynomial> ")",
};

// Operators

AddOp: BinOp = "+" => BinOp::Add;
ThinOp: BinOp = { "->" => BinOp::ThinTx, "<-" => BinOp::ThinRx };
FatOp: BinOp = { "=>" => BinOp::FatTx, "<=" => BinOp::FatRx };

// Identifiers

CesIdent: String = r"[A-Z][A-Za-z0-9_]*" => <>.to_owned();
NodeIdent: String = r"[a-z][A-Za-z0-9_]*" => <>.to_owned();
UnderIdent: String = r"_[A-Za-z0-9_]*" => <>.to_owned();

// Literals

// size = digit { digit } ;
// string = "\"" { any_char } "\"" ;
Literal: Literal = {
    r"[0-9]+" => Literal::from_digits(<>).unwrap(),
    r#""[^"]*""# => Literal::from_quoted_str(<>).unwrap(),
};
